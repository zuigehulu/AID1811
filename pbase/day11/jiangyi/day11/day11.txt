day10回顾
  全局变量
    一但创建,不会自动销毁,需要用del语句销毁
  局部变量
    在函数调用时(过程中)创建,自动销毁
  globals
    返回全局变量的字典
  locals
    返回局部变量的字典
  函数变量
    函数名是变量,它在创建时绑定一个"函数"
    函数可以作为形参传入另一个函数
    函数可以作用另一个函数的返回值
    函数嵌套定义
        def f1():
            def f2():
                print("hello")
            return f2
        fx = f1()
        fx()
    示例2:
        def fn(fx):
            print("fn被调用")
            return fx
        
        m = fn(max)
        print(m(1,2,3))

  作用域
    局部
    外部嵌套函数作用域
    全局(模块内)
    内建(内置)函数作用域
  global 语句
    声明 为全局作用域
      global v
  nonlocal  语句
    声明为外部嵌套函数作用域
  
  lambda 表达式
    创建函数的表达式 
    主要是用来创建简单函数
    lambda x, y, *args, **kwargs: x + y + sum(args)

  eval 函数
    把字符串当成 "表达式" 来运行,返回表达式的运算结果
  exec
    把字符串当成 python语言的程序来运行
  

day11
函数式编程 functional programming
  函数式编程是指用一系列函数解决问题

  说明:
    用每一个函数完成细小的功能,一系列函数任意组成可以解决大问题
    函数仅接受输入并产生输出,不包含任何能影响输出的内部状态

  示例见:
    day10_exercise/sum_1_100.py

函数的可重入性
  当一个函数没有访问除局部变量以外的变量,则此函数为可重入函数

  特点:
    输入一定.结果必须一定
  示例:
    # 以下为可重入函数
    def myadd(x, y):  # 此函数没有访问全局或外部嵌套函数的变量
        print(x + y)
    print(myadd(100, 200))  # 300

    # 以下为不可重入函数
    s = 0
    def myadd(x, y):
        print(x + y + s)  # 注:  s为全局变量
    print(myadd(100, 200))  # 300
    s = 10000
    print(myadd(100, 200))  # 10300
    


高阶函数 High Order Function
  什么是高阶函数?
    满足下列条件中一个的函数即为高阶函数
      1. 函数接受一个或多个函数作为参数传入
      2. 函数返回一个函数


python 内建的高阶函数
  map   filter  sorted

map函数 
  格式:
    map(func, iterable1, iterable2, ...)
  作用:
    用iterable1, iterable2中取出的数据用func处理后返回
    处理后的结果
  参数:
    func 数据处理函数
    iterable1, iterable2  可以迭代对象
  返回值:
    可迭代对象
  示例:
    def power2(x):
        return x ** 2

    for x in map(power2, range(1, 10)):
        print(x)

  说明:
    func函数的形参列表的形参个数与map函数中可迭代对象的个数
    相关,一般func函数的形参个数等于map函数中的可迭代对象的个数
  示例:
    # 生成一个可迭代对象, 此可迭代对象可以生成:
    #   1**4, 2**3, 3**2, 4**1
    # pow(x, y, z=None)

    for x in map(pow, [1, 2, 3, 4], (4, 3, 2, 1)):
       print(x)

练习:
  1. 求 1**2 + 2**2 + 3**2 + ... + 9**2 的和
  2. 求 1**3 + 2**3 + 3**3 + ... + 9**3 的和
  3. 求 1**9 + 2**8 + 3**7 + ... + 9**1 的和

filter 函数
  格式:
    filter(func, iterable)
  作用:
    创建一个可迭代对象,此可迭代对象将用func函数对iterable中
    的数据进行筛选
  参数:
    func 筛选函数,有一个形参, 通常返回True/False
    iterable  原始的可迭代数据
  返回值:
    可迭代对象
示例:
  def isodd(x):
      '''此函数判断x是否为奇数,如果为奇数返回True'''
      return x % 2 == 1

  # 打印1~10以内的所有奇数:
  for x in filter(isodd, range(10)):
      print(x)

  # 生成 10 以内所有偶数的列表[0, 2, 4, 6, 8]
  L = list( filter(lambda x: x%2==0, range(10)) )
  print(L)

练习:
  用filter 函数将 1 ~ 100 之间所有的素数prime存放于列表中
  
sorted 函数:
  作用:
    将原可迭代对象的数据进行排序,生成排序后的列表
  格式:
    sorted(iterable, key=None, reverse=False)
  参数:
    iterable 可迭代对象 
    key 函数,用来提供一个排序的依据值,默认用原值进行比较
        key函数传入的是要比较的数据对象,返回值为能进行比较的值
    reverse 标志用来设置是否降序排序
  返回值:
    排序后的列表
示例:
  L = [5, -2, -4, 0, 3, 1]
  L2 = sorted(L)  # L2 = [-4, -2, 0, 1, 3, 5]
  L3 = sorted(L, reverse=True)  # [5, 3, 1, 0, -2, -4]
  L4 = sorted(L, key=abs)       # [0, 1, -2, 3, -4, 5]


key 函数的格式:
  def xxx(a[需要比较的数据]):
      return a的依据

示例2:
  names = ['Tom', 'Jerry', 'Spike', 'Tyke']
  L1= sorted(names)  # ['Jerry', 'Spike', 'Tom', 'Tyke']
  L2 = sorted(names, key=len)

练习:
  以下列表的中的数据进行排序
    L = [(1, 5), (3, 9), (4, 1), (3, 6), (5, 3)]
  1. 将列表内的五个元组按,第二个数据的从小到大的顺序进行排序
    结果如下:
    L = [(4, 1), (5, 3), (1, 5), (3, 6), (3, 9) ]

  2. 将列表内的五个元组按第二个数的从大到小顺序进行排序,打印
     排序之后的结果

  3. 假设元组中的数据是数学直角坐标系的坐标,则按他们距离原点
     的距离进行排序
     (提示: 距离等同于 distance = sqrt(x**2 + y**2))


小结:
  三个高阶函数
    map(func, 可迭代对象1, 可迭代对象2)
       对一个或多个可迭代的数据处理
    filter(func, 可迭代对象)
       过滤
    sorted(可迭代对象,key=函数, reverse=False)
       排序


递归 Recursion
  递归是指函数直接或间接的调用自身

示意:
  def f():
      f()  # 直接调用自身
  f()

  # 间接调用自身
  def fa():
      fb()
  def fb():
      fa()
  fa()

说明:
  递归一定要控制递归的层数，当符合一定条件时要终止递归
  几乎所有的递归都能用while循环来代替

递归分为两个阶段:
  递推阶段:
    从原问题出发，按递归公式,从未知到已知,最终返回
  回归阶段
    按递归终止条件，逆向代入递归公式,回归到原问题求解

问题:
  局部变量在什么时候会自动销毁？
    函数结束后才自动销毁(如果函数尚末结束则局部变量不会销毁)
  同一个函数能有几个同名的局部变量？
    调用几次就有几个局部变量
    

示例见:
  recursion.py
  recursion_factorial.py

练习:
  1. 试写一个递归函数 mysum(n), 此函数用递归方式求
    1 + 2 + 3 + 4 + .... + n 的和
    def mysum(n):
        .... # 此处自己实现
    print(mysum(100))  # 5050

  2. 已知有五位朋友在一起:
    第五个人说他比第四个人大2岁
    第四个人说他比第三个人大2岁
    第三个人说他比第二个人大2岁
    第二个人说他比第一个人大2岁
    第一个人说他十岁
    写函数get_age(n)求 第三个人几岁，第五个人几岁
    
递归的优缺点:
  # 递归一定要控制递归的层数，当符合某一条件时要终止递归调用
  优点:
    递归可以把问题简单化，让思路更用清晰，代码更简洁
  缺点:
    递归因系统环境影响大，当递归深度太大时，可能会得到不可
    预知的结果



闭包 closure

什么是闭包
  闭包是指引用的了此函数外部嵌套函数的变量的函数

闭包必须满足三个条件:
  1. 必须有一个内嵌函数
  2. 内嵌函数必须引用外部函数中的变量
  3. 外部函数返回值必须是嵌套函数

思考:
  全局变量和局部变量的区别?
    全局变量
      一直存在,谁都可以访问和修改
    局部变量
      只是在调用时存在,只能在函数内部进行访问和修改

示例见:
  closure.py 
  closure2.py

闭包的优缺点:
  优点:
    加强封装性，用内部嵌套函数可以使用函数之外的变量而不会被
    破坏
  缺点:
    由于闭包会使得函数中的变量都被保存在内存中，内存销耗量大,
    所以不能滥用闭包


练习:
  1. 已知有列表：
    L = [[3, 5, 8], 10, [[13, 14], 15, 18], 20]
    1) 写一个函数 print_list(lst) 打印出所有的数字
       如:
         print_list(L)  # 打印 3 5 8 10 13 14
    2) 写一个函数 sum_list(lst) 返回这个列表中所有数字的和
       如:
         print(sum_list(L))  # 106
    注:
      type(x) 函数可以返回一个对象的类型
      如: type(20) is int  # True
          type([1, 2, 3]) is list  # True

  2.  写程序求出1~20的阶乘的和
     即:  1!+2!+3!+....+20!

  3. 改写之前的学生信息管理程序,添加如下四个功能:
      | 5)  按学生成绩高~低显示学生信息 |
      | 6)  按学生成绩低~高显示学生信息 |
      | 7)  按学生年龄高~低显示学生信息 |
      | 8)  按学生年龄低~高显示学生信息 |





